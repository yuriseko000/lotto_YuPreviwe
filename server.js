
const express = require("express");
const sqlite3 = require("sqlite3").verbose();
const cors = require("cors");
const bcrypt = require("bcrypt");

const app = express();
const port = 3000;

app.use(cors());
app.use(express.json());

const db = new sqlite3.Database("./lotto.db", (err) => {
  if (err) console.error("Failed to open DB:", err.message);
  else console.log("Connected to SQLite database.");
});

// ------------------- Utils -------------------
async function hashPassword(password) {
  const saltRounds = 10;
  return await bcrypt.hash(password, saltRounds);
}

// ------------------- Seed Admin -------------------
async function seedAdmin() {
  const adminEmail = "admin@example.com";
  const adminPassword = "admin123";

  db.get("SELECT * FROM customer WHERE email = ?", [adminEmail], async (err, row) => {
    if (err) return console.error(err);
    if (!row) {
      const hashedPassword = await hashPassword(adminPassword);
      db.run(
        "INSERT INTO customer (fullname, phone, email, password, wallet_balance, role) VALUES (?, ?, ?, ?, ?, ?)",
        ["Administrator", "0000000000", adminEmail, hashedPassword, 1000, "admin"]
      );
      console.log(`Admin account created: ${adminEmail} / ${adminPassword}`);
    } else {
      console.log("Admin account already exists");
    }
  });
}

// ------------------- Create Tables -------------------
db.serialize(() => {
  db.run(`
    CREATE TABLE IF NOT EXISTS customer (
      cus_id INTEGER PRIMARY KEY AUTOINCREMENT,
      fullname TEXT,
      phone TEXT,
      email TEXT UNIQUE,
      password TEXT,
      wallet_balance REAL DEFAULT 0,
      role TEXT DEFAULT 'user'
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS lotto (
      lotto_id INTEGER PRIMARY KEY AUTOINCREMENT,
      number TEXT,
      round INTEGER,
      price REAL DEFAULT 80,
      status TEXT DEFAULT 'available'
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS purchase (
      purchase_id INTEGER PRIMARY KEY AUTOINCREMENT,
      cus_id INTEGER,
      lotto_id INTEGER,
      round INTEGER,
      purchase_date TEXT DEFAULT CURRENT_TIMESTAMP,
      is_redeemed INTEGER DEFAULT 0,
      FOREIGN KEY (cus_id) REFERENCES customer(cus_id),
      FOREIGN KEY (lotto_id) REFERENCES lotto(lotto_id)
    )
  `);

  db.run(`
    CREATE TABLE IF NOT EXISTS prize (
      prize_id INTEGER PRIMARY KEY AUTOINCREMENT,
      round INTEGER,
      prize_type TEXT,
      number TEXT,
      reward_amount REAL
    )
  `, (err) => {
    if (!err) seedAdmin();
  });
});

// ------------------- Helper: Generate Lotto -------------------
function generateLotto(round, amount = 100) {
  return new Promise((resolve, reject) => {
    db.serialize(async () => {
      db.run("DELETE FROM lotto WHERE round = ?", [round], async (err) => {
        if (err) return reject(err);

        const generated = new Set();
        const stmt = db.prepare("INSERT INTO lotto (number, round, price, status) VALUES (?, ?, ?, ?)");

        while (generated.size < amount) {
          const num = String(Math.floor(Math.random() * 1000000)).padStart(6, "0");
          if (!generated.has(num)) {
            generated.add(num);
            await new Promise((res, rej) =>
              stmt.run(num, round, 80, "available", (err) => err ? rej(err) : res())
            );
          }
        }

        stmt.finalize((err) => {
          if (err) return reject(err);
          resolve(Array.from(generated));
        });
      });
    });
  });
}

// ------------------- Draw Prizes Helper -------------------
function drawPrizes(round) {
  return new Promise((resolve, reject) => {
    db.get("SELECT COUNT(*) AS cnt FROM prize WHERE round = ?", [round], (err, row) => {
      if (err) return reject(err);
      if (row.cnt > 0) return reject("‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏á‡∏ß‡∏î‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß");

      db.all("SELECT number FROM lotto WHERE round = ?", [round], (err, rows) => {
        if (err) return reject(err);
        if (!rows || rows.length === 0) return reject("‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏•‡∏Ç Lotto ‡∏á‡∏ß‡∏î‡∏ô‡∏µ‡πâ");

        // shuffle numbers
        const shuffled = rows.map(r => r.number).sort(() => 0.5 - Math.random());

        const firstPrizeFull = shuffled[0]; // ‡πÄ‡∏•‡∏Ç‡πÄ‡∏ï‡πá‡∏°‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 1
        const secondPrizeFull = shuffled[1] || null;
        const thirdPrizeFull = shuffled[2] || null;
        const last3 = firstPrizeFull.slice(-3); // ‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 3 ‡∏ï‡∏±‡∏ß‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 1
        const last2Random = String(Math.floor(Math.random() * 100)).padStart(2, "0"); // ‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 2 ‡∏ï‡∏±‡∏ß‡∏™‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà

        const prizes = [
          { prize_type: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 1", number: firstPrizeFull, reward_amount: 6000000 },
          { prize_type: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 2", number: secondPrizeFull, reward_amount: 200000 },
          { prize_type: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 3", number: thirdPrizeFull, reward_amount: 80000 },
          { prize_type: "‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 3 ‡∏ï‡∏±‡∏ß", number: last3, reward_amount: 4000 },
          { prize_type: "‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 2 ‡∏ï‡∏±‡∏ß", number: last2Random, reward_amount: 2000 },
        ];

        const stmt = db.prepare(
          "INSERT INTO prize (round, prize_type, number, reward_amount) VALUES (?, ?, ?, ?)"
        );

        // run inserts and wait for completion
        const insertPromises = prizes.map(p => {
          return new Promise((res, rej) => {
            stmt.run(round, p.prize_type, p.number, p.reward_amount, (err) => {
              if (err) return rej(err);
              res();
            });
          });
        });

        Promise.all(insertPromises)
          .then(() => {
            stmt.finalize((err) => {
              if (err) return reject(err);
              resolve(prizes);
            });
          })
          .catch((e) => reject(e));
      });
    });
  });
}

// ------------------- API -------------------

// Register
app.post("/register", async (req, res) => {
  const { fullname, phone, email, password, wallet_balance } = req.body;
  if (!fullname || !phone || !email || !password)
    return res.status(400).json({ error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô" });

  try {
    const hashedPassword = await hashPassword(password);
    const role = "user";
    const balance = wallet_balance || 0;
    db.run(
      `INSERT INTO customer (fullname, phone, email, password, wallet_balance, role)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [fullname, phone, email, hashedPassword, balance, role],
      function (err) {
        if (err) return res.status(400).json({ error: err.message });
        res.status(201).json({
          message: "‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
          cus_id: this.lastID,
          fullname,
          phone,
          email,
          wallet_balance: balance,
          role,
        });
      }
    );
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Login
app.post("/login", (req, res) => {
  const { email, password } = req.body;
  if (!email || !password)
    return res.status(400).json({ error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å email ‡πÅ‡∏•‡∏∞ password" });

  db.get("SELECT * FROM customer WHERE email = ?", [email], async (err, user) => {
    if (err) return res.status(500).json({ error: err.message });
    if (!user) return res.status(401).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ô‡∏µ‡πâ" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(401).json({ message: "‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });

    const customer = {
      cus_id: user.cus_id,
      fullname: user.fullname,
      phone: user.phone,
      email: user.email,
      wallet_balance: user.wallet_balance,
      role: user.role,
    };

    res.json({
      message: "‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      customer,
    });
  });
});

// Current round (next)
app.get("/current-round", (req, res) => {
  db.get("SELECT MAX(round) as maxRound FROM lotto", [], (err, row) => {
    if (err) return res.status(500).json({ error: err.message });
    const nextRound = (row?.maxRound || 0) + 1;
    res.json({ round: nextRound });
  });
});

// Generate lotto
app.post("/generate", async (req, res) => {
  try {
    const row = await new Promise((resolve, reject) =>
      db.get("SELECT MAX(round) as maxRound FROM lotto", (err, r) => err ? reject(err) : resolve(r))
    );

    const round = (row?.maxRound || 0) + 1;

    if (round > 1) {
      const prevRound = round - 1;
      const r = await new Promise((resolve, reject) =>
        db.get("SELECT COUNT(*) as cnt FROM prize WHERE round = ?", [prevRound], (err, r) =>
          err ? reject(err) : resolve(r)
        )
      );

      if (r.cnt === 0)
        return res.status(400).json({ message: "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏≠‡∏≠‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏á‡∏ß‡∏î‡∏Å‡πà‡∏≠‡∏ô" });
    }

    const lottoNumbers = await generateLotto(round, 100);
    res.json({ message: `‡∏™‡∏£‡πâ‡∏≤‡∏á Lotto ‡∏á‡∏ß‡∏î ${round} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à üéâ`, lottoNumbers, round });

  } catch (e) {
    console.error(e);
    res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á Lotto", error: e.toString() });
  }
});
// ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡πÉ‡∏ä‡πâ Express ‡πÅ‡∏•‡∏∞ DB ‡πÄ‡∏õ‡πá‡∏ô MySQL / PostgreSQL

app.post("/draw-from-sold/:round", (req, res) => {
  const round = req.params.round;

  // 1. ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏£‡∏≠‡∏ö‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏¢‡∏±‡∏á
  db.all("SELECT * FROM prize WHERE round = ?", [round], (err, existingPrizes) => {
    if (err) return res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ö‡∏ô server" });

    if (existingPrizes.length > 0) {
      return res.status(400).json({ message: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏á‡∏ß‡∏î‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏™‡∏∏‡πà‡∏°‡πÅ‡∏•‡πâ‡∏ß", prizes: existingPrizes });
    }

    // 2. ‡∏î‡∏∂‡∏á‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß
    db.all(
      "SELECT number FROM lotto WHERE round = ? AND status = 'sold'",
      [round],
      (err, rows) => {
        if (err) return res.status(500).json({ message: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏ö‡∏ô server" });

        if (!rows || rows.length === 0) {
          return res.status(400).json({ message: "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏•‡∏Ç‡∏Ç‡∏≤‡∏¢" });
        }

        // 3. ‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏•‡∏Ç
        const soldNumbers = rows.map(r => r.number);
        const shuffled = [...soldNumbers].sort(() => 0.5 - Math.random());
        const firstPrize = shuffled[0];
        const secondPrize = shuffled[1] || "-";
        const thirdPrize = shuffled[2] || "-";

        // ‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 3 ‡∏ï‡∏±‡∏ß = ‡∏à‡∏≤‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 1
        const last3 = firstPrize.slice(-3);

        // ‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 2 ‡∏ï‡∏±‡∏ß = ‡∏™‡∏∏‡πà‡∏°‡∏à‡∏≤‡∏Å‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡∏à‡∏£‡∏¥‡∏á
        const last2Candidate = soldNumbers[Math.floor(Math.random() * soldNumbers.length)];
        const last2 = last2Candidate.slice(-2);

        const prizes = [
          { prize_type: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 1", number: firstPrize, reward_amount: 6000000 },
          { prize_type: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 2", number: secondPrize, reward_amount: 200000 },
          { prize_type: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 3", number: thirdPrize, reward_amount: 80000 },
          { prize_type: "‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 3 ‡∏ï‡∏±‡∏ß", number: last3, reward_amount: 4000 },
          { prize_type: "‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 2 ‡∏ï‡∏±‡∏ß", number: last2, reward_amount: 2000 },
        ];

        // 4. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á DB
        const stmt = db.prepare(
          "INSERT INTO prize (round, prize_type, number, reward_amount) VALUES (?, ?, ?, ?)"
        );

        for (const p of prizes) {
          stmt.run(round, p.prize_type, p.number, p.reward_amount);
        }

        stmt.finalize((err) => {
          if (err) return res.status(500).json({ message: "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß" });
          res.json({ message: "‡∏™‡∏∏‡πà‡∏°‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏à‡∏≤‡∏Å‡πÄ‡∏•‡∏Ç‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢ üéâ", prizes });
        });
      }
    );
  });
});


//--------------‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏•‡∏≠‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ã‡∏∑‡πâ‡∏≠ ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ cus_id (‡∏£‡∏´‡∏±‡∏™‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤) ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏£‡∏∞‡∏ö‡∏∏----------------------------------------------------------------------------
app.get("/my-lotto/:cus_id", (req, res) => { //‡∏™‡∏£‡πâ‡∏≤‡∏á get ‡∏£‡∏±‡∏ö cus_id ‡∏à‡∏≤‡∏Å url
  const cusId = req.params.cus_id; //‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ cus_id ‡∏à‡∏≤‡∏Å URL parameter
  db.all( 
    `SELECT p.purchase_id, l.lotto_id, l.number, p.round, p.purchase_date, p.is_redeemed 
     FROM purchase p
     JOIN lotto l ON p.lotto_id = l.lotto_id
     WHERE p.cus_id = ?
     ORDER BY p.purchase_date DESC`,
     // SELECT ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•
     // FROM ‡πÄ‡∏≠‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á purchase
     // JOIN ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡∏≤‡∏£‡∏≤‡∏á purchase ‡∏Å‡∏±‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á lotto ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç lotto_id ‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô
     // WHERE ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡πÇ‡∏î‡∏¢‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà cus_id ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡∏°‡∏≤
     // ORDER BY ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ã‡∏∑‡πâ‡∏≠‡∏à‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏õ‡πÄ‡∏Å‡πà‡∏≤
    [cusId],
    (err, rows) => {
      if (err) return res.status(500).json({ error: err.message }); //‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ñ‡πâ‡∏≤‡∏°‡∏µ error
      res.json({ myLotto: rows }); //‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πàerror ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö JSON
    }
  );
});
//--------------‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏•‡∏≠‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ã‡∏∑‡πâ‡∏≠ ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ cus_id (‡∏£‡∏´‡∏±‡∏™‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤) ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏£‡∏∞‡∏ö‡∏∏----------------------------------------------------------------------------



// Sold numbers
app.get("/sold-lotto/:round", (req, res) => {
  const round = req.params.round;
  db.all(
    "SELECT number FROM lotto WHERE round = ? AND status = 'sold'",
    [round],
    (err, rows) => {
      if (err) return res.status(500).json({ error: err.message });
      const sold_numbers = rows.map(r => r.number);
      res.json({ message: "‡∏î‡∏∂‡∏á‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏Ç‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß", soldNumbers: sold_numbers });
    }
  );
});

// Prize info
app.get("/prize/:round", (req, res) => {
  const round = req.params.round;
  db.all("SELECT * FROM prize WHERE round = ?", [round], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    if (rows.length === 0) return res.json({ message: "‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡∏∏‡πà‡∏°‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•", prizes: [] });
    res.json({ message: "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏á‡∏ß‡∏î‡∏ô‡∏µ‡πâ", prizes: rows });
  });
});

// Draw prizes
app.post("/draw-prizes/:round", async (req, res) => {
  const round = req.params.round;
  try {
    const prizes = await drawPrizes(round);
    res.json({ message: "‡∏™‡∏∏‡πà‡∏°‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", prizes });
  } catch (e) {
    res.status(400).json({ message: e.toString() });
  }
});


//---------------------------‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏•‡∏≠‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà----------------------------------------------------------------
app.post("/redeem/:purchase_id", (req, res) => { // ‡∏™‡∏£‡πâ‡∏≤‡∏á post ‡∏£‡∏±‡∏ö purchase_id ‡∏à‡∏≤‡∏Å url
  const purchaseId = req.params.purchase_id; // ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤ purchase_id ‡∏à‡∏≤‡∏Å URL parameter

  db.get("SELECT * FROM purchase WHERE purchase_id = ?", [purchaseId], (err, row) => { // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á purchase ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ purchase_id ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏°‡∏≤
    if (err) return res.status(500).json({ error: err.message }); // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ñ‡πâ‡∏≤‡∏°‡∏µ error
    if (!row) return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠" }); // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠
    if (row.is_redeemed) return res.status(400).json({ message: "‡∏Ñ‡∏∏‡∏ì‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡πÅ‡∏•‡πâ‡∏ß" }); // ‡∏ñ‡πâ‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß

    const cusId = row.cus_id; // ‡∏î‡∏∂‡∏á cus_id ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠

    db.get("SELECT number, round FROM lotto WHERE lotto_id = ?", [row.lotto_id], (err, lottoRow) => { // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πá‡∏≠‡∏ï‡πÇ‡∏ï‡πâ‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á lotto ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ lotto_id ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ã‡∏∑‡πâ‡∏≠
      if (err) return res.status(500).json({ error: err.message }); // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ñ‡πâ‡∏≤‡∏°‡∏µ error
      if (!lottoRow) return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏•‡∏Ç‡∏•‡πá‡∏≠‡∏ï‡πÇ‡∏ï‡πâ" }); // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πá‡∏≠‡∏ï‡πÇ‡∏ï‡πâ

      const lottoNumber = lottoRow.number; // ‡∏î‡∏∂‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏•‡πá‡∏≠‡∏ï‡πÇ‡∏ï‡πâ
      const round = lottoRow.round; // ‡∏î‡∏∂‡∏á‡∏£‡∏≠‡∏ö

      db.all("SELECT * FROM prize WHERE round = ?", [round], (err, prizeRows) => { // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏à‡∏≤‡∏Å‡∏ï‡∏≤‡∏£‡∏≤‡∏á prize ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πá‡∏≠‡∏ï‡πÇ‡∏ï‡πâ
        if (err) return res.status(500).json({ error: err.message }); // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ñ‡πâ‡∏≤‡∏°‡∏µ error
 
        const matchedPrizes = []; // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏≤‡πÄ‡∏£‡∏¢‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡πá‡∏ö‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•

        for (const p of prizeRows) { // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
          if (!p.prize_type) continue; // ‡∏Ç‡πâ‡∏≤‡∏°‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•
          switch (p.prize_type) { // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•
            case "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 1": 
            case "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 2":
            case "‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà 3":
              if (lottoNumber === p.number) matchedPrizes.push(p); // ‡∏ñ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏•‡πá‡∏≠‡∏ï‡πÇ‡∏ï‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏• ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ô‡∏µ‡πâ‡∏•‡∏á‡πÉ‡∏ô‡∏≠‡∏≤‡πÄ‡∏£‡∏¢‡πå
              break;
            case "‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 3 ‡∏ï‡∏±‡∏ß":
              if (lottoNumber.slice(-3) === p.number) matchedPrizes.push(p); // ‡∏ñ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç 3 ‡∏ï‡∏±‡∏ß‡∏ó‡πâ‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ô‡∏µ‡πâ‡∏•‡∏á‡πÉ‡∏ô‡∏≠‡∏≤‡πÄ‡∏£‡∏¢‡πå
              break;
            case "‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢ 2 ‡∏ï‡∏±‡∏ß":
              if (lottoNumber.slice(-2) === p.number) matchedPrizes.push(p); // ‡∏ñ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç 2 ‡∏ï‡∏±‡∏ß‡∏ó‡πâ‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ô‡∏µ‡πâ‡∏•‡∏á‡πÉ‡∏ô‡∏≠‡∏≤‡πÄ‡∏£‡∏¢‡πå
              break;
          }
        }

        if (matchedPrizes.length === 0) // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•
          return res.status(400).json({ message: "‡πÄ‡∏•‡∏Ç‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•" }); // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö

        const totalReward = matchedPrizes.reduce((sum, p) => sum + p.reward_amount, 0); // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏¢‡∏≠‡∏î‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏£‡∏ß‡∏°

        // ‡πÄ‡∏û‡∏¥‡πà‡∏° wallet + ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó is_redeemed
        db.serialize(() => {
          db.run("BEGIN TRANSACTION"); // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô transaction ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

          db.run( // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô wallet ‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
            "UPDATE customer SET wallet_balance = wallet_balance + ? WHERE cus_id = ?", // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡πÄ‡∏Ç‡πâ‡∏≤ wallet
            [totalReward, cusId] 
          );

          db.run( // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á purchase
            "UPDATE purchase SET is_redeemed = 1 WHERE cus_id = ? AND round = ? AND lotto_id = ?", // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó is_redeemed ‡πÄ‡∏õ‡πá‡∏ô 1 (‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡πÅ‡∏•‡πâ‡∏ß)
            [cusId, round, row.lotto_id]
          );

          db.run("COMMIT", (err) => { // ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            if (err) return res.status(500).json({ error: err.message }); // ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏ñ‡πâ‡∏≤‡∏°‡∏µ error

            res.json({ 
              message: "‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö
              totalReward, 
              prizes: matchedPrizes.map(p => ({ prizeType: p.prize_type, number: p.number, rewardAmount: p.reward_amount })), // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•
            });
          });
        });
      });
    });
  });
});
//---------------------------‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•‡∏•‡∏≠‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà----------------------------------------------------------------



// Reset system
app.post("/reset-system", (req, res) => {
  db.serialize(() => {
    db.run("DELETE FROM lotto");
    db.run("DELETE FROM purchase");
    db.run("DELETE FROM prize");
    db.run("DELETE FROM customer WHERE role!='admin'", (err) => {
      if (err) return res.status(500).json({ error: err.message });

      db.run("DELETE FROM sqlite_sequence WHERE name='lotto'");
      db.run("DELETE FROM sqlite_sequence WHERE name='purchase'");
      db.run("DELETE FROM sqlite_sequence WHERE name='prize'");
      db.run("DELETE FROM sqlite_sequence WHERE name='customer' AND seq>0");

      res.json({ message: "‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß ‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô admin" });
    });
  });
});

// Buy Lotto (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ï‡∏£‡∏ß‡∏à‡∏¢‡∏≠‡∏î, ‡∏´‡∏±‡∏Å‡∏¢‡∏≠‡∏î, ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞)
app.post("/buy", (req, res) => {
  const { cus_id, lotto_id, round } = req.body;

  if (!cus_id || !lotto_id || !round)
    return res.status(400).json({ error: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏∞‡∏ö‡∏∏ cus_id, lotto_id, round" });

  // first: get lotto to know price
  db.get("SELECT * FROM lotto WHERE lotto_id = ? AND round = ?", [lotto_id, round], (err, lotto) => {
    if (err) return res.status(500).json({ error: err.message });
    if (!lotto) return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏•‡∏Ç‡∏ô‡∏µ‡πâ" });
    if (lotto.status !== "available")
      return res.status(400).json({ message: "‡πÄ‡∏•‡∏Ç‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ã‡∏∑‡πâ‡∏≠‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß" });

    const price = lotto.price || 80;

    // then check customer balance
    db.get("SELECT * FROM customer WHERE cus_id = ?", [cus_id], (err, customer) => {
      if (err) return res.status(500).json({ error: err.message });
      if (!customer) return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤" });

      if (Number(customer.wallet_balance) < Number(price)) {
        return res.status(400).json({ message: "‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠" });
      }

      // proceed: update lotto status -> insert purchase -> deduct wallet -> respond
      db.run("UPDATE lotto SET status = 'sold' WHERE lotto_id = ?", [lotto_id], (err) => {
        if (err) return res.status(500).json({ error: err.message });

        db.run(
          `INSERT INTO purchase (cus_id, lotto_id, round) VALUES (?, ?, ?)`,
          [cus_id, lotto_id, round],
          function (err) {
            if (err) return res.status(500).json({ error: err.message });

            // deduct wallet
            db.run(
              "UPDATE customer SET wallet_balance = wallet_balance - ? WHERE cus_id = ?",
              [price, cus_id],
              (err) => {
                if (err) return res.status(500).json({ error: err.message });

                // get updated balance
                db.get("SELECT wallet_balance FROM customer WHERE cus_id = ?", [cus_id], (err, row) => {
                  if (err) return res.status(500).json({ error: err.message });

                  res.json({
                    message: "‡∏ã‡∏∑‡πâ‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
                    purchase_id: this.lastID,
                    lotto: {
                      lotto_id,
                      number: lotto.number,
                      round,
                    },
                    wallet_balance: row ? row.wallet_balance : null,
                  });
                });
              }
            );
          }
        );
      });
    });
  });
});

// Get available lotto numbers of a round
app.get("/lotto/:round", (req, res) => {
  const round = req.params.round;
  db.all(
    "SELECT * FROM lotto WHERE round = ? AND status = 'available'",
    [round],
    (err, rows) => {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ lotto: rows });
    }
  );
});

app.get("/last-round", (req, res) => {
  db.get("SELECT MAX(round) as maxRound FROM lotto", [], (err, row) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ round: row?.maxRound || 0 });
  });
});

// Start server
app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});